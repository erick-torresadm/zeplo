/**
 * Sistema de detec√ß√£o de palavras-chave direta e envio para webhook
 * 
 * Este m√≥dulo oferece uma abordagem simplificada e direta para detectar
 * palavras-chave em mensagens e enviar para o webhook externo.
 * 
 * IMPORTANTE: Inclui suporte para detec√ß√£o autom√°tica de palavras-chave espec√≠ficas como "chat"
 * para responder sem interven√ß√£o manual.
 */

import axios from 'axios';
import { log } from './vite';
import { storage } from './storage';
import { evolutionApi } from './evolution-api';
import { MessageFlow } from '@shared/schema';

// URL do webhook externo configurado
const EXTERNAL_WEBHOOK_URL = 'https://editor.membropro.com.br/webhook-test/receber';

/**
 * Processa diretamente uma mensagem e envia para o webhook externo se contiver palavra-chave
 * @param messageData Dados da mensagem a ser processada
 */
export async function processMessageDirectly(messageData: {
  instanceId: string,
  instanceName: string,
  messageContent: string,
  messageId?: string,
  timestamp?: number
}): Promise<boolean> {
  fromNumber: string,√¶√¶√¶√¶√¶√¶
  try {
    log(`[DirectWebhook] Processando mensagem diretamente: "${messageData.messageContent.substring(0, 50)}${messageData.messageContent.length > 50 ? '...' : ''}"`, 'webhook');
    
    // Busca todos os fluxos de mensagens ativos da inst√¢ncia
    const activeFlows = flows.filter(flow => flow.status === 'active');
    
    if (activeFlows.length === 0) {
      log(`[DirectWebhook] Nenhum fluxo ativo encontrado para a inst√¢ncia ${messageData.instanceName}`, 'webhook');
      const flows = await storage.getMessageFlowsByInstanceId(message√¶√¶√¶√¶√¶√¶Data.instanceId);
      return false;
    }
    
    // Verifica√ß√£o especial para a palavra-chave "chat", que deve ser processada prioritariamente
    const messageContent = messageData.messageContent.toLowerCase();
    if (messageContent.includes('chat')) {
      log(`[DirectWebhook] üîî Palavra-chave priorit√°ria "chat" encontrada! Processando imediatamente...`, 'webhook');
      
      // Busca ou usa o primeiro fluxo dispon√≠vel para responder
      const chatFlow = activeFlows.find(f => f.keyword.toLowerCase() === 'chat') || activeFlows[0];
      
      if (chatFlow) {
        // Envio autom√°tico para webhook, assim como envio da resposta direta
        processWebhookAndSendResponse(chatFlow, messageData);
        return true;
      }
    }
    
    // Verifica cada palavra-chave dos fluxos
    for (const flow of activeFlows) {
      const keyword = flow.keyword.toLowerCase();
      
      let isMatch = false;
      
      // Verifica de acordo com o tipo de gatilho
      const triggerType = flow.triggerType as string || 'exact_match';
      
      console.log(`[DirectWebhook] Verificando fluxo "${flow.name}" - Tipo: ${triggerType}, Keyword: "${keyword}"`);
      
      // Se n√£o houver tipo de gatilho definido, assume exact_match
      if (!triggerType || triggerType === 'undefined') {
        console.log(`[DirectWebhook] Tipo de gatilho n√£o definido para o fluxo "${flow.name}", assumindo 'exact_match'`);
      }
      
      // Correspond√™ncia exata (com suporte para h√≠fen ou underscore na nomenclatura)
      // Adicionando log para diagn√≥stico profundo do problema
      console.log(`[DirectWebhook] Diagn√≥stico detalhado:
        - Tipo de gatilho: "${triggerType}"
        - √â exact_match? ${triggerType === 'exact_match'}
        - √â exact-match? ${triggerType === 'exact-match'}
        - Palavra-chave: "${keyword}"
        - Mensagem: "${messageContent}"
        - Mensagem === keyword? ${messageContent === keyword}
        - Mensagem.trim() === keyword.trim()? ${messageContent.trim() === keyword.trim()}
        - Mensagem.includes(keyword)? ${messageContent.includes(keyword)}
        - √â all_messages? ${triggerType === 'all_messages' || triggerType === 'all-messages'}
      `);
      
      // Correspond√™ncia exata (com suporte para h√≠fen ou underscore)
      if ((triggerType === 'exact-match' || triggerType === 'exact_match') && 
          (messageContent === keyword || messageContent.trim() === keyword.trim())) {
        console.log(`[DirectWebhook] ‚úì Correspond√™ncia EXATA encontrada: "${messageContent}" = "${keyword}"`);
        isMatch = true;
      } 
      // Cont√©m a palavra-chave
      else if ((triggerType === 'contains' || triggerType === 'contains') && messageContent.includes(keyword)) {
        console.log(`[DirectWebhook] ‚úì Palavra-chave CONTIDA na mensagem: "${messageContent}" cont√©m "${keyword}"`);
        isMatch = true;
      } 
      // Todas as mensagens (sempre corresponde)
      else if (triggerType === 'all-messages' || triggerType === 'all_messages') {
        console.log(`[DirectWebhook] ‚úì Fluxo configurado para TODAS AS MENSAGENS`);
        isMatch = true;
      }
      
      // M√âTODO ALTERNATIVO DE VERIFICA√á√ÉO: Se ainda n√£o deu match, tentar novamente com verifica√ß√£o mais flex√≠vel
      if (!isMatch) {
        // Verifica√ß√£o mais permissiva para casos problem√°ticos
        if ((triggerType === 'exact-match' || triggerType === 'exact_match') &&
            messageContent.indexOf(keyword) === 0) {
          console.log(`[DirectWebhook] ‚úì Correspond√™ncia de IN√çCIO encontrada (alternativa): "${messageContent}" come√ßa com "${keyword}"`);
          isMatch = true;
        } else if (triggerType === 'contains' || triggerType === '') {
          // Se for "contains" ou n√£o tiver tipo definido, ser mais flex√≠vel
          if (messageContent.includes(keyword) || keyword.includes(messageContent)) {
            console.log(`[DirectWebhook] ‚úì Correspond√™ncia CONTIDA flex√≠vel encontrada: "${messageContent}" e "${keyword}" t√™m sobreposi√ß√£o`);
            isMatch = true;
          }
        }
      }
      
      // Log do resultado da verifica√ß√£o
      console.log(`[DirectWebhook] Resultado final da verifica√ß√£o: ${isMatch ? 'CORRESPONDE' : 'N√ÉO corresponde'}`);
      
      
      // Log quando n√£o encontra correspond√™ncia
      if (!isMatch) {
        console.log(`[DirectWebhook] ‚úó Sem correspond√™ncia para "${keyword}" na mensagem: "${messageContent}"`);
      }
      
      // Se encontrou correspond√™ncia, envia diretamente para o webhook
      if (isMatch) {
        log(`[DirectWebhook] ‚úÖ Palavra-chave "${keyword}" encontrada! Enviando para webhook...`, 'webhook');
        
        // Prepara dados para o webhook
        const queryParams = new URLSearchParams();
        queryParams.append('instanceId', messageData.instanceId);
        queryParams.append('keyword', flow.keyword || '');
        queryParams.append('numero', messageData.fromNumber);
        queryParams.append('mensagem', messageData.messageContent);
        
        // Adiciona dados da conversa
        const conversation = {
          flowName: flow.name,
          keyword: flow.keyword,
          flowId: flow.id,
          text: typeof flow.messages === 'string' 
            ? flow.messages 
            : Array.isArray(flow.messages) 
              ? flow.messages.map((m: any) => typeof m === 'string' ? m : m.text || m.caption || '').join(' ') 
              : JSON.stringify(flow.messages)
        };
        
        queryParams.append('conversation', JSON.stringify(conversation));
        queryParams.append('flowId', flow.id || '');
        queryParams.append('flowName', flow.name || '');
        queryParams.append('timestamp', String(new Date().getTime()));
        
        // URL com query parameters
        const fullUrl = `${EXTERNAL_WEBHOOK_URL}?${queryParams.toString()}`;
        log(`[DirectWebhook] Enviando GET para URL: ${fullUrl}`, 'webhook');
        
        try {
          // Envia para o webhook externo usando GET com timeout reduzido
          const response = await axios.get(fullUrl, {
            headers: {
              'Accept': 'application/json'
            },
            timeout: 5000
          });
          
          log(`[DirectWebhook] ‚úÖ Webhook notificado com sucesso: ${response.status}`, 'webhook');
          
          // Registra no hist√≥rico de mensagens
          await storage.createMessageHistory(flow.userId, {
            instanceId: messageData.instanceId,
            sender: messageData.fromNumber,
            messageContent: messageData.messageContent,
            flowId: flow.id,
            triggeredKeyword: flow.keyword,
            instanceName: messageData.instanceName,
            status: "triggered",
            timestamp: new Date(messageData.timestamp || Date.now())
          });
          
          return true;
        } catch (error: any) {
          const errorMessage = error.response 
            ? `${error.response.status}: ${JSON.stringify(error.response.data)}`
            : error.message || 'Erro desconhecido';
          
          log(`[DirectWebhook] ‚ùå Erro ao notificar webhook: ${errorMessage}`, 'webhook');
        }
      }
    }
    
    log(`[DirectWebhook] Nenhuma palavra-chave correspondente encontrada`, 'webhook');
    return false;
  } catch (error: any) {
    log(`[DirectWebhook] Erro ao processar mensagem: ${error.message}`, 'webhook');
    console.error('[DirectWebhook] Erro completo:', error);
    return false;
  }
}

/**
 * Processa um fluxo detectado e automaticamente envia resposta ao usu√°rio
 * @param flow O fluxo de mensagens que foi acionado
 * @param messageData Os dados da mensagem recebida
 */
async function processWebhookAndSendResponse(
  flow: MessageFlow,
  messageData: {
    instanceId: string,
    instanceName: string,
    fromNumber: string,
    messageContent: string,
    messageId?: string,
    timestamp?: number
  }
): Promise<boolean> {
  try {
    log(`[DirectWebhook] üöÄ Processando fluxo "${flow.name}" e enviando resposta autom√°tica...`, 'webhook');
    
    // Prepara dados para o webhook
    const queryParams = new URLSearchParams();
    queryParams.append('instanceId', messageData.instanceId);
    queryParams.append('keyword', flow.keyword || '');
    queryParams.append('numero', messageData.fromNumber);
    queryParams.append('mensagem', messageData.messageContent);
    
    // Adiciona dados da conversa
    const conversation = {
      flowName: flow.name,
      keyword: flow.keyword,
      flowId: flow.id,
      text: typeof flow.messages === 'string' 
        ? flow.messages 
        : Array.isArray(flow.messages) 
          ? flow.messages.map((m: any) => typeof m === 'string' ? m : m.text || m.caption || '').join(' ') 
          : JSON.stringify(flow.messages)
    };
    
    queryParams.append('conversation', JSON.stringify(conversation));
    queryParams.append('flowId', flow.id || '');
    queryParams.append('flowName', flow.name || '');
    queryParams.append('timestamp', String(new Date().getTime()));
    
    // URL com query parameters
    const fullUrl = `${EXTERNAL_WEBHOOK_URL}?${queryParams.toString()}`;
    log(`[DirectWebhook] Enviando GET para URL: ${fullUrl}`, 'webhook');
    
    // Registra no hist√≥rico de mensagens
    await storage.createMessageHistory(flow.userId, {
      instanceId: messageData.instanceId,
      instanceName: messageData.instanceName,
      sender: messageData.fromNumber,
      messageContent: messageData.messageContent,
      flowId: flow.id,
      triggeredKeyword: flow.keyword,
      status: "triggered",
      timestamp: new Date(messageData.timestamp || Date.now())
    });
    
    // Enviar notifica√ß√£o para o webhook externo (n√£o aguardamos a resposta)
    axios.get(fullUrl, {
      headers: {
        'Accept': 'application/json'
      },
      timeout: 5000
    })
    .then(response => {
      log(`[DirectWebhook] ‚úÖ Webhook notificado com sucesso: ${response.status}`, 'webhook');
    })
    .catch(error => {
      const errorMessage = error.response 
        ? `${error.response.status}: ${JSON.stringify(error.response.data)}`
        : error.message || 'Erro desconhecido';
      
      log(`[DirectWebhook] ‚ùå Erro ao notificar webhook: ${errorMessage}`, 'webhook');
    });
    
    // Processamento das mensagens
    let messagesArray: any[] = [];
    
    try {
      // Normaliza as mensagens para um array padronizado
      if (typeof flow.messages === 'string') {
        try {
          // Tenta fazer parse da string como JSON
          messagesArray = JSON.parse(flow.messages);
        } catch (jsonError) {
          // Se falhar no parse, trata como string simples
          messagesArray = [{ text: flow.messages, type: 'text', delay: 0 }];
        }
      } else if (Array.isArray(flow.messages)) {
        messagesArray = flow.messages;
      } else if (flow.messages && typeof flow.messages === 'object') {
        messagesArray = [flow.messages];
      } else {
        messagesArray = [];
      }
      
      // Normaliza√ß√£o do formato das mensagens
      messagesArray = messagesArray.map(msg => {
        if (typeof msg === 'string') {
          return { text: msg, type: 'text', delay: 0 };
        }
        return msg;
      }).filter(msg => msg && (
        typeof msg === 'string' || 
        msg.text || 
        msg.mediaUrl || 
        (msg.type && ['image', 'audio', 'video', 'document', 'button'].includes(msg.type))
      ));
    } catch (error: any) {
      log(`[DirectWebhook] Erro ao processar formato das mensagens: ${error.message}`, 'webhook');
      messagesArray = [];
    }
    
    // Verifica se h√° mensagens para enviar
    if (messagesArray.length === 0) {
      log(`[DirectWebhook] ‚ö†Ô∏è Fluxo sem mensagens configuradas`, 'webhook');
      return true; // Retorna true porque o webhook foi notificado com sucesso
    }
    
    // Enviar as mensagens
    const messages = messagesArray;
    for (const message of messages) {
      try {
        // Trata strings como mensagens de texto simples para compatibilidade
        if (typeof message === 'string') {
          await evolutionApi.sendMessage(messageData.instanceName, messageData.fromNumber, message);
          log(`[DirectWebhook] Resposta de texto enviada: "${String(message).substring(0, 30)}..."`, 'webhook');
          continue;
        }
        
        // Tratamento dos diferentes tipos de mensagem
        if (typeof message === 'object' && message !== null) {
          const messageType = message.type || 'text';
          
          switch (messageType) {
            case 'text':
              if ('text' in message) {
                await evolutionApi.sendMessage(messageData.instanceName, messageData.fromNumber, message.text);
                log(`[DirectWebhook] Resposta de texto enviada: "${String(message.text).substring(0, 30)}..."`, 'webhook');
              }
              break;
              
            case 'image':
              if ('mediaUrl' in message) {
                await evolutionApi.sendImageMessage(
                  messageData.instanceName, 
                  messageData.fromNumber, 
                  message.mediaUrl, 
                  'caption' in message ? String(message.caption || '') : ''
                );
                log(`[DirectWebhook] Imagem enviada com URL: ${message.mediaUrl}`, 'webhook');
              }
              break;
              
            case 'audio':
              if ('mediaUrl' in message) {
                await evolutionApi.sendAudioMessage(
                  messageData.instanceName, 
                  messageData.fromNumber, 
                  message.mediaUrl
                );
                log(`[DirectWebhook] √Åudio enviado com URL: ${message.mediaUrl}`, 'webhook');
              }
              break;
              
            case 'video':
              if ('mediaUrl' in message) {
                await evolutionApi.sendVideoMessage(
                  messageData.instanceName, 
                  messageData.fromNumber, 
                  message.mediaUrl, 
                  'caption' in message ? String(message.caption || '') : ''
                );
                log(`[DirectWebhook] V√≠deo enviado com URL: ${message.mediaUrl}`, 'webhook');
              }
              break;
              
            case 'document':
              if ('mediaUrl' in message && 'fileName' in message) {
                await evolutionApi.sendDocumentMessage(
                  messageData.instanceName, 
                  messageData.fromNumber, 
                  message.mediaUrl, 
                  String(message.fileName || 'documento.pdf')
                );
                log(`[DirectWebhook] Documento enviado: ${message.fileName}`, 'webhook');
              }
              break;
              
            case 'button':
              if ('text' in message && 'buttons' in message && Array.isArray(message.buttons)) {
                await evolutionApi.sendButtonMessage(
                  messageData.instanceName,
                  messageData.fromNumber,
                  String(message.text),
                  message.buttons
                );
                log(`[DirectWebhook] Mensagem com bot√µes enviada`, 'webhook');
              }
              break;
              
            default:
              log(`[DirectWebhook] Tipo de mensagem n√£o suportado: ${messageType}`, 'webhook');
          }
        }
        
        // Aguarda um pouco entre cada mensagem para evitar flood
        const delay = (typeof message === 'object' && 'delay' in message) ? 
                      (Number(message.delay) * 1000) : 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      } catch (msgError: any) {
        log(`[DirectWebhook] Erro ao enviar mensagem: ${msgError.message}`, 'webhook');
      }
    }
    
    return true;
  } catch (error: any) {
    const errorMessage = error.response 
      ? `${error.response.status}: ${JSON.stringify(error.response.data)}`
      : error.message || 'Erro desconhecido';
    
    log(`[DirectWebhook] ‚ùå Erro ao processar resposta autom√°tica: ${errorMessage}`, 'webhook');
    console.error('[DirectWebhook] Erro completo:', error);
    return false;
  }
}

/**
 * Teste direto de uma palavra-chave em uma inst√¢ncia espec√≠fica
 * @param instanceId ID da inst√¢ncia
 * @param keyword Palavra-chave a ser testada
 * @param phoneNumber N√∫mero de telefone opcional (padr√£o: n√∫mero de teste)
 */
export async function testKeywordDirectly(
  instanceId: string,
  keyword: string,
  phoneNumber: string = '5511999999999'
): Promise<{success: boolean, message: string}> {
  try {
    // Busca a inst√¢ncia
    const instance = await storage.getInstance(instanceId);
    if (!instance) {
      return {
        success: false,
        message: "Inst√¢ncia n√£o encontrada"
      };
    }
    
    log(`[DirectWebhook] Testando palavra-chave "${keyword}" para inst√¢ncia ${instance.name}`, 'webhook');
    
    // Simula uma mensagem com a palavra-chave
    return processMessageDirectly({
      instanceId,
      instanceName: instance.name,
      fromNumber: phoneNumber,
      messageContent: keyword,
      messageId: `test-${Date.now()}`,
      timestamp: Date.now()
    }).then(success => {
      if (success) {
        return {
          success: true,
          message: `Palavra-chave "${keyword}" detectada e enviada para webhook com sucesso!`
        };
      } else {
        return {
          success: false,
          message: `Palavra-chave "${keyword}" n√£o foi detectada em nenhum fluxo ativo.`
        };
      }
    });
  } catch (error: any) {
    return {
      success: false,
      message: `Erro ao testar palavra-chave: ${error.message}`
    };
  }
}